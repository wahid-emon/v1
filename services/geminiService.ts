import { GoogleGenAI } from "@google/genai";
import { UserProfile, MeetingSpot } from "../types";

// Initialize Gemini Client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Suggest public meeting spots using Google Maps Grounding
export const getMeetingSuggestions = async (
  district: string,
  user1: UserProfile,
  user2: UserProfile
): Promise<MeetingSpot[]> => {
  try {
    const prompt = `
      Suggest 3 specific, safe, and quiet public places (cafes, parks, or community centers) in the Berlin district of ${district} 
      that would be suitable for a conversation between two people.
      One person enjoys: ${user1.interests.join(', ')}.
      The other enjoys: ${user2.interests.join(', ')}.
      Focus on places with a relaxed atmosphere suitable for an elderly person and a student to talk.
    `;

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        tools: [{ googleMaps: {} }],
      },
    });

    const spots: MeetingSpot[] = [];

    // Extract grounding chunks if available (Google Maps Grounding)
    const candidates = response.candidates;
    if (candidates && candidates[0]?.groundingMetadata?.groundingChunks) {
      const chunks = candidates[0].groundingMetadata.groundingChunks;
      
      chunks.forEach((chunk) => {
        if (chunk.maps) {
          spots.push({
            title: chunk.maps.title || "Suggested Location",
            address: "Address available in map",
            description: "A recommended spot based on your location preferences.",
            url: chunk.maps.uri
          });
        }
      });
    }

    // Fallback or specific text parsing if grounding didn't return strict structured data in the way we want,
    // or to augment with the text description generated by the model.
    // However, for this demo, if we get grounding chunks, we trust them. 
    // If we got NO grounding chunks, we might parse the text, but the prompt explicitly asked for this.
    
    // If no map data found, we return a generic error spot or parse text (simplified for this demo)
    if (spots.length === 0 && response.text) {
        // Fallback: Just return the text as a single description
        spots.push({
            title: "Gemini Suggestions",
            description: response.text,
            url: ""
        });
    }

    return spots;

  } catch (error) {
    console.error("Error fetching meeting spots:", error);
    return [
      {
        title: "Local Cafe",
        description: "Please check your local maps for a quiet cafe in " + district,
      }
    ];
  }
};

// Generate icebreakers based on shared interests
export const getConversationStarters = async (
  user1: UserProfile,
  user2: UserProfile
): Promise<string[]> => {
  try {
    const prompt = `
      Generate 5 warm, friendly, and respectful conversation starters for a meeting between:
      1. ${user1.name} (Age: ${user1.age}, Interests: ${user1.interests.join(', ')})
      2. ${user2.name} (Age: ${user2.age}, Interests: ${user2.interests.join(', ')})
      
      The conversation will be in German (or mixed). Provide the starters in German with an English translation in parentheses.
      Keep it simple and suitable for a first meeting in a cafe.
      Return ONLY a JSON array of strings.
    `;

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        responseMimeType: "application/json"
      }
    });

    const text = response.text;
    if (!text) return ["Wie geht es Ihnen? (How are you?)"];
    
    return JSON.parse(text) as string[];

  } catch (error) {
    console.error("Error generating icebreakers:", error);
    return [
      "Was machen Sie gerne in Ihrer Freizeit? (What do you like to do in your free time?)",
      "Wie lange wohnen Sie schon in Berlin? (How long have you lived in Berlin?)"
    ];
  }
};